apiVersion: v1
kind: ConfigMap
metadata:
  name: filestash-config-generator
  namespace: filestash
data:
  generate-config.go: |
    package main

    import (
    	"bytes"
    	"compress/zlib"
    	"crypto/aes"
    	"crypto/cipher"
    	"crypto/rand"
    	"crypto/sha256"
    	"encoding/base64"
    	"encoding/json"
    	"fmt"
    	"os"

    	"golang.org/x/crypto/bcrypt"
    )

    var Letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")

    func ReversedBaseChange(alphabet []rune, i int) string {
    	str := ""
    	for {
    		str += string(alphabet[i%len(alphabet)])
    		i = i / len(alphabet)
    		if i == 0 {
    			break
    		}
    	}
    	return str
    }

    func hashSize(b []byte, n int) string {
    	h := ""
    	for i := 0; i < len(b); i++ {
    		if n > 0 && len(h) >= n {
    			break
    		}
    		h += ReversedBaseChange(Letters, int(b[i]))
    	}
    	if len(h) > n {
    		return h[0 : len(h)-1]
    	}
    	return h
    }

    func Hash(str string, n int) string {
    	hasher := sha256.New()
    	hasher.Write([]byte(str))
    	return hashSize(hasher.Sum(nil), n)
    }

    func Encrypt(secret string, plaintext []byte) string {
    	// Derive key the same way Filestash does:
    	// 1. SECRET_KEY_DERIVATE_FOR_PROOF = Hash("PROOF_" + secret, len(secret))
    	// 2. key = Hash(derivate, 16) -> 16-char base62 string used as AES key
    	derivedKey := Hash("PROOF_"+secret, len(secret))
    	key := Hash(derivedKey, 16)

    	block, _ := aes.NewCipher([]byte(key))
    	gcm, _ := cipher.NewGCM(block)

    	// Compress (use default level like Filestash does)
    	compressed := bytes.NewBuffer(nil)
    	w := zlib.NewWriter(compressed)
    	w.Write(plaintext)
    	w.Close()

    	// Encrypt
    	nonce := make([]byte, gcm.NonceSize())
    	rand.Read(nonce)
    	ciphertext := gcm.Seal(nil, nonce, compressed.Bytes(), nil)

    	// Combine
    	result := make([]byte, len(nonce)+len(ciphertext))
    	copy(result, nonce)
    	copy(result[len(nonce):], ciphertext)

    	return base64.URLEncoding.EncodeToString(result)
    }

    func HashPassword(password string) string {
    	hash, _ := bcrypt.GenerateFromPassword([]byte(password), 10)
    	return string(hash)
    }

    func main() {
    	configPath := os.Getenv("CONFIG_PATH")
    	if configPath == "" {
    		configPath = "/app/data/state/config/config.json"
    	}

    	forceRegenerate := os.Getenv("FORCE_REGENERATE") == "true"
    	applicationURL := os.Getenv("APPLICATION_URL")

    	// Check existing config
    	if !forceRegenerate {
    		if data, err := os.ReadFile(configPath); err == nil {
    			var existing map[string]interface{}
    			if json.Unmarshal(data, &existing) == nil {
    				general, _ := existing["general"].(map[string]interface{})
    				auth, _ := existing["auth"].(map[string]interface{})
    				middleware, _ := existing["middleware"].(map[string]interface{})

    				hostCorrect := general != nil && general["host"] == applicationURL
    				hasAdmin := auth != nil && auth["admin"] != nil
    				hasMiddleware := middleware != nil

    				if hostCorrect && hasAdmin && hasMiddleware {
    					fmt.Println("Config already properly configured, skipping generation")
    					return
    				}
    				if !hostCorrect {
    					fmt.Printf("Host mismatch: %v vs %s, regenerating...\n", general["host"], applicationURL)
    				} else if !hasMiddleware {
    					fmt.Println("Middleware not configured, regenerating...")
    				} else {
    					fmt.Println("Existing config incomplete, regenerating...")
    				}
    			}
    		}
    	} else {
    		fmt.Println("FORCE_REGENERATE=true, regenerating config...")
    	}

    	// Get secret key
    	secretKey := os.Getenv("FILESTASH_SECRET_KEY")
    	if len(secretKey) < 16 {
    		b := make([]byte, 24)
    		rand.Read(b)
    		secretKey = base64.StdEncoding.EncodeToString(b)[:32]
    		fmt.Println("Generated random secret_key")
    	}

    	// Build config
    	config := map[string]interface{}{
    		"general": map[string]interface{}{
    			"name":       "Filestash",
    			"port":       8334,
    			"host":       applicationURL,
    			"secret_key": secretKey,
    			"force_ssl":  true,
    		},
    		"auth": map[string]interface{}{},
    		"log": map[string]interface{}{
    			"level":     "INFO",
    			"telemetry": false,
    		},
    		"features": map[string]interface{}{
    			"api": map[string]interface{}{
    				"enable": true,
    			},
    		},
    	}

    	// Add admin password
    	adminPassword := os.Getenv("FILESTASH_ADMIN_PASSWORD")
    	if adminPassword != "" {
    		config["auth"].(map[string]interface{})["admin"] = HashPassword(adminPassword)
    		fmt.Println("Admin password configured")
    	}

    	// Note: Authentication is handled by oauth2-proxy in front of Filestash
    	// No native OIDC middleware configuration needed

    	// Add S3 backend
    	s3Endpoint := os.Getenv("S3_ENDPOINT")
    	s3AccessKey := os.Getenv("S3_ACCESS_KEY")
    	s3SecretKey := os.Getenv("S3_SECRET_KEY")
    	s3Bucket := os.Getenv("S3_BUCKET")
    	s3Region := os.Getenv("S3_REGION")
    	if s3Region == "" {
    		s3Region = "us-east-1"
    	}

    	if s3Endpoint != "" && s3AccessKey != "" && s3SecretKey != "" && s3Bucket != "" {
    		config["connections"] = []map[string]interface{}{
    			{
    				"type":              "s3",
    				"label":             "Cloud Storage",
    				"endpoint":          s3Endpoint,
    				"access_key_id":     s3AccessKey,
    				"secret_access_key": s3SecretKey,
    				"bucket":            s3Bucket,
    				"region":            s3Region,
    				"path":              "/",
    			},
    		}
    		fmt.Println("S3 backend configured")

    		// Configure passthrough middleware with direct strategy
    		// This auto-connects authenticated users (via oauth2-proxy) to S3
    		config["middleware"] = map[string]interface{}{
    			"identity_provider": map[string]interface{}{
    				"type": "passthrough",
    				"params": map[string]interface{}{
    					"strategy": "direct",
    				},
    			},
    			"attribute_mapping": map[string]interface{}{
    				"related_backend": "s3",
    				"params": map[string]interface{}{
    					"endpoint":          s3Endpoint,
    					"access_key_id":     s3AccessKey,
    					"secret_access_key": s3SecretKey,
    					"bucket":            s3Bucket,
    					"region":            s3Region,
    					"path":              "/",
    				},
    			},
    		}
    		fmt.Println("Passthrough middleware configured for auto-login")
    	}

    	// Write config
    	jsonData, _ := json.MarshalIndent(config, "", "  ")
    	os.MkdirAll("/app/data/state/config", 0755)
    	os.WriteFile(configPath, jsonData, 0644)
    	fmt.Printf("Config written to %s\n", configPath)
    }
